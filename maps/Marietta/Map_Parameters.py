import numpy as np
import cv2
import matplotlib.pyplot as plt
from datetime import date
from scipy import interpolate
import math

#Function for extracting position and timestamps out of a text file with the extracted
#pose message. The text are generated by running extractMessages on a bag,

def positionExtractor(poseFilename):
    f = open(poseFilename, 'r')
    timestamps, X, Y = [], [], []
    f.readline()
    for line in f:
        l = line.split(',')
        timestamps.append(float(l[0]))
        X.append(float(l[5]))
        Y.append(float(l[6]))
    return X, Y, timestamps

def dist(x1,y1,x2,y2):
    return ((x1-x2)**2+(y1-y2)**2)**(1/2.0)


#Put in the name of the files that contain the track survey data. These should be text files generated from bags
#using the extractMessages.py script. The extractMessages generates text files for many different topics, 
#pose_estimate.txt is the one required here.
innerBoundary = positionExtractor("inner_boundary_survey.txt")
outerBoundary = positionExtractor("outer_boundary_survey.txt")

XinOrig, YinOrig = innerBoundary[0], innerBoundary[1]
XoutOrig, YoutOrig = outerBoundary[0], outerBoundary[1]

#Tune the starting and ending indices so that the there is minimal overlap and 
#no positions from before the survey began.
inStart, inEnd = 100, len(XinOrig) - 625
outStart, outEnd = 250, len(XoutOrig) - 650

# plt.plot(XinOrig[inStart:inEnd], YinOrig[inStart:inEnd])
# plt.plot(XoutOrig[outStart:outEnd], YoutOrig[outStart:outEnd])
# plt.show()


#Clip the ends and downsample track survey data
downsamplingFactor = 10
Xin = XinOrig[inStart:inEnd][0::downsamplingFactor]
Yin = YinOrig[inStart:inEnd][0::downsamplingFactor]
Xout = XoutOrig[outStart:outEnd][0::downsamplingFactor]
Yout = YoutOrig[outStart:outEnd][0::downsamplingFactor]

#Compute the centerline based on the left and right track boundaries
Xcen, Ycen, Xw = [], [], []
for ii,(x,y) in enumerate(zip(Xin,Yin)):
    xc, yc = 0.0, 0.0
    currentDistance = np.inf
    for x2,y2 in zip(Xout,Yout):
        distance = dist(x,y,x2,y2)
        if distance < currentDistance:
            currentDistance = distance
            xc = x-((x-x2)/2.0)
            yc = y-((y-y2)/2.0)
    Xcen.append(xc)
    Ycen.append(yc)
    Xw.append(currentDistance)


Xcen1 = Xcen
Xcen1.append(Xcen[0])
Ycen1 = Ycen
Ycen1.append(Ycen[0])

dx = np.diff(Xcen1)
dy = np.diff(Ycen1)
dx1 = np.append(dx,dx[0])
dy1 = np.append(dy,dy[0])

ddx = np.diff(dx1)
ddy = np.diff(dy1)



def calc_yaw(i, dx, dy):
        yaw = math.atan2(dy[i], dx[i])
        return yaw

# def calc_curvature(i, dx, dy, ddx, ddy):
#         """
#         calc curvature
#         """
#         k = (ddy[i] * dx[i] - ddx[i] * dy[i]) / ((dx[i] ** 2 + dy[i] ** 2)**(3 / 2))
#         return k

d_B = []
d_C = []
d_D = []
d_E = []

for i in range(len(Xcen)):
	d_B.append(dist(Xcen[i], Ycen[i], 3.06525,-3.24617))
	d_C.append(dist(Xcen[i], Ycen[i], 9.6007, 6.41657))
	d_D.append(dist(Xcen[i], Ycen[i], 1.527115, 13.013))
	d_E.append(dist(Xcen[i], Ycen[i], -6.05883, 3.94158))

i_B = d_B.index(min(d_B))
i_C = d_C.index(min(d_C))
i_D = d_D.index(min(d_D))
i_E = d_E.index(min(d_E))

print(i_B)
yaw_A =  calc_yaw(0, dx, dy)
yaw_B =  calc_yaw(i_B, dx, dy)
yaw_C =  calc_yaw(i_C, dx, dy)
yaw_D =  calc_yaw(i_D, dx, dy)
yaw_E =  calc_yaw(i_E, dx, dy)

l_A = dist(Xcen[0], Ycen[0], Xcen[i_B], Ycen[i_B])
# l_A = dist(Xcen[0], Ycen[0], Xcen[i_B], Ycen[i_B])
l_C = dist(Xcen[i_C], Ycen[i_C], Xcen[i_D], Ycen[i_D])
# l_A = dist(Xcen[0], Ycen[0], Xcen[i_B], Ycen[i_B])
l_E = dist(Xcen[i_E], Ycen[i_E], Xcen[0], Ycen[0])

len_B = []
len_D = []
cur_B = 2 / dist(Xcen[i_B], Ycen[i_B], Xcen[i_C], Ycen[i_C])
cur_D = 2 / dist(Xcen[i_D], Ycen[i_D], Xcen[i_E], Ycen[i_E])

for i in range(i_B,i_C):
	len_B.append(dist(Xcen[i], Ycen[i], Xcen[i+1], Ycen[i+1]))
	# cur_B.append(calc_curvature(i, dx, dy, ddx, ddy))

for i in range(i_D,i_E):
	len_D.append(dist(Xcen[i], Ycen[i], Xcen[i+1], Ycen[i+1]))
	# cur_D.append(calc_curvature(i, dx, dy, ddx, ddy))

l_B = sum(len_B)
l_D = sum(len_D)
print("cur_B:")
print(cur_B)

print("cur_D:")
print(cur_D)

print("X_A: ", Xcen[0], "Y: ", Ycen[0],  "yaw_A: ", yaw_A, "l_A: ", l_A)
print("X_B: ", Xcen[i_B], "Y: ", Ycen[i_B],  "yaw_B: ", yaw_B, "l_B: ", l_A+l_B)
print("X_C: ", Xcen[i_C], "Y: ", Ycen[i_C],  "yaw_C: ", yaw_C, "l_C: ", l_A+l_B + l_C)
print("X_D: ", Xcen[i_D], "Y: ", Ycen[i_D],  "yaw_D: ", yaw_D, "l_D: ", l_A+l_B + l_C + l_D)
print("X_E: ", Xcen[i_E], "Y: ", Ycen[i_E],  "yaw_E: ", yaw_E, "l_E: ", l_A+l_B + l_C + l_D + l_E)

#Plot the centerline and two boundaries
plt.plot(Xin, Yin)
plt.plot(Xout, Yout)
plt.plot(Xcen,Ycen)
plt.plot(Xcen[0],Ycen[0], 'k*', linewidth=2, markersize=12)
plt.plot(Xcen[i_B],Ycen[i_B], 'k*', linewidth=2, markersize=12)
plt.plot(Xcen[i_C],Ycen[i_C], 'k*', linewidth=2, markersize=12)
plt.plot(Xcen[i_D],Ycen[i_D], 'k*', linewidth=2, markersize=12)
plt.plot(Xcen[i_E],Ycen[i_E], 'k*', linewidth=2, markersize=12)
print("Circle 1 CenterX: ", (Xcen[i_B]+Xcen[i_C] )/ 2)
print("Circle 1 CenterY: ", (Ycen[i_B]+Ycen[i_C] )/ 2)
print("Circle 1 Radius:", dist(Xcen[i_B], Ycen[i_B], Xcen[i_C], Ycen[i_C])/2)

print("Circle 2 CenterX: ", (Xcen[i_D]+Xcen[i_E] )/ 2)
print("Circle 2 CenterY: ", (Ycen[i_D]+Ycen[i_E] )/ 2)
print("Circle 1 Radius:", dist(Xcen[i_D], Ycen[i_D], Xcen[i_E], Ycen[i_E])/2)

circle1=plt.Circle(((Xcen[i_B]+Xcen[i_C] )/ 2,(Ycen[i_B]+Ycen[i_C] )/ 2),dist(Xcen[i_B], Ycen[i_B], Xcen[i_C], Ycen[i_C])/2, color='k', fill=False)
circle2=plt.Circle(((Xcen[i_D]+Xcen[i_E] )/ 2,(Ycen[i_D]+Ycen[i_E] )/ 2),dist(Xcen[i_D], Ycen[i_D], Xcen[i_E], Ycen[i_E])/2, color='k', fill=False)
line1 = plt.plot( [ 2.78,-5.92], [-2.97,3.8] ,'k', linewidth=2, markersize=12) 
line2 = plt.plot( [10.04,1.46],  [6.19, 13.11],'k', linewidth=2, markersize=12 )
ax = plt.gca()
ax.add_artist(circle1)
ax.add_artist(circle2)

plt.show()

#Plot the width (not to scale, this is just a sanity check)
# plt.scatter(Xcen,Ycen,s=np.asarray(Xw)*100)
# plt.show()

